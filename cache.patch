diff --git a/3rdparty/ZipArchive.h b/3rdparty/ZipArchive.h
index 7c6c924..425c8cc 100755
--- a/3rdparty/ZipArchive.h
+++ b/3rdparty/ZipArchive.h
@@ -29,7 +29,7 @@
 	id			_delegate;
 }
 
-@property (nonatomic, retain) id delegate;
+@property (nonatomic, assign) id delegate;
 
 -(BOOL) CreateZipFile2:(NSString*) zipFile;
 -(BOOL) CreateZipFile2:(NSString*) zipFile Password:(NSString*) password;
diff --git a/3rdparty/ZipArchive.m b/3rdparty/ZipArchive.m
index 6c3cb32..2fd5193 100755
--- a/3rdparty/ZipArchive.m
+++ b/3rdparty/ZipArchive.m
@@ -37,6 +37,8 @@
 -(void) dealloc
 {
 	[self CloseZipFile2];
+	self.delegate = nil;
+	
 	[super dealloc];
 }
 
diff --git a/AFCache.h b/AFCache.h
index 7d1f906..5ae194f 100755
--- a/AFCache.h
+++ b/AFCache.h
@@ -84,7 +84,9 @@ enum {
 	
 	BOOL downloadPermission_;
     BOOL wantsToArchive_;
-    
+    BOOL pauseDownload_;
+    BOOL isInstancedCache_;
+    NSString* context_;
     NSOperationQueue* packageArchiveQueue_;
 }
 
@@ -99,6 +101,11 @@ enum {
 @property (nonatomic, assign) double diskCacheDisplacementTresholdSize;
 @property (nonatomic, assign) int concurrentConnections;
 @property BOOL downloadPermission;
+@property BOOL pauseDownload;
+
++ (NSString*)rootPath;
++ (void)setRootPath:(NSString*)rootPath;
++ (AFCache*)cacheForContext:(NSString*)context;
 
 + (AFCache *)sharedInstance;
 
@@ -162,6 +169,7 @@ enum {
 - (BOOL)isConnectedToNetwork;
 - (int)totalRequestsForSession;
 - (int)requestsPending;
+- (void)prioritizeItem:(AFCacheableItem*)item;
 - (void)doHousekeeping;
 - (BOOL)hasCachedItemForURL:(NSURL *)url;
 - (unsigned long)diskCacheSize;
@@ -169,5 +177,6 @@ enum {
 - (void)cancelAsynchronousOperationsForURL:(NSURL *)url itemDelegate:(id)aDelegate didLoadSelector:(SEL)selector;
 - (void)cancelAsynchronousOperationsForDelegate:(id)aDelegate;
 - (NSArray*)cacheableItemsForURL:(NSURL*)url;
+- (NSArray*)cacheableItemsForDelegate:(id)delegate didFinishSelector:(SEL)didFinishSelector;
 - (void)flushDownloadQueue;
 @end
diff --git a/AFCache.m b/AFCache.m
index 3978b89..80636db 100755
--- a/AFCache.m
+++ b/AFCache.m
@@ -58,19 +58,28 @@ extern NSString* const UIApplicationWillResignActiveNotification;
 @implementation AFCache
 
 static AFCache *sharedAFCacheInstance = nil;
-static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
+static const NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
+static NSString* AFCache_rootPath = nil;
+static NSMutableDictionary* AFCache_contextCache = nil;
 
 @synthesize cacheEnabled, dataPath, cacheInfoStore, pendingConnections,downloadQueue, maxItemFileSize, diskCacheDisplacementTresholdSize, suffixToMimeTypeMap;
 @synthesize clientItems;
 @synthesize concurrentConnections;
+@synthesize pauseDownload = pauseDownload_;
 
 @synthesize downloadPermission = downloadPermission_;
 
 
 #pragma mark init methods
 
-- (id)init {
-	self = [super init];
+- (id)initWithContext:(NSString*)context {
+	if (nil == context && sharedAFCacheInstance != nil)
+    {
+        [self release];
+        return [AFCache sharedInstance];
+    }
+    
+    self = [super init];
 	if (self != nil) {
 #if TARGET_OS_IPHONE
         [[NSNotificationCenter defaultCenter] addObserver:self
@@ -83,7 +92,20 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
                                                      name:UIApplicationWillTerminateNotification
                                                    object:nil];        
 #endif
-		[self reinitialize];
+        if (nil == AFCache_contextCache)
+        {
+            AFCache_contextCache = [[NSMutableDictionary alloc] init];
+        }
+        
+        if (nil != context)
+        {
+            [AFCache_contextCache setObject:[NSValue valueWithPointer:self] forKey:context];
+        }
+        
+        context_ = [context copy];
+        isInstancedCache_ = (context != nil);
+        self.downloadPermission = YES;
+        [self reinitialize];
 		[self initMimeTypes];
 	}
 	return self;
@@ -103,6 +125,12 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 }
 
 - (void)setDataPath:(NSString*)newDataPath {
+    if (isInstancedCache_ && nil != dataPath)
+    {
+        NSLog(@"Error: Can't change data path on instanced AFCache");
+        NSAssert(NO, @"Can't change data path on instanced AFCache");
+        return;
+    }
     if (wantsToArchive_) {
         [archiveTimer invalidate];
         [self archiveWithInfoStore:cacheInfoStore];
@@ -115,6 +143,46 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
     self.maxItemFileSize = fileSize;
 }
 
++ (NSString*)rootPath
+{
+    if (nil == AFCache_rootPath)
+    {
+        NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
+        AFCache_rootPath = [[paths objectAtIndex: 0] copy];
+    }
+    return AFCache_rootPath;
+}
+
++ (void)setRootPath:(NSString *)rootPath
+{
+    if (AFCache_rootPath != rootPath)
+    {
+        [AFCache_rootPath release];
+    }
+    AFCache_rootPath = [rootPath copy];
+}
+
++ (AFCache*)cacheForContext:(NSString *)context
+{
+    if (nil == AFCache_contextCache)
+    {
+        AFCache_contextCache = [[NSMutableDictionary alloc] init];
+    }
+    
+    if (nil == context)
+    {
+        return [self sharedInstance];
+    }
+    
+    AFCache* cache = [[AFCache_contextCache objectForKey:context] pointerValue];
+    if (nil == cache)
+    {
+        cache = [[[[self class] alloc] initWithContext:context] autorelease];
+    }
+    
+    return cache;
+}
+
 // The method reinitialize really initializes the cache.
 // This is usefull for testing, when you want to, uh, reinitialize
 
@@ -130,11 +198,17 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 	concurrentConnections = kAFCacheDefaultConcurrentConnections;
 	maxItemFileSize = kAFCacheDefaultMaxFileSize;
 	
-	NSArray *paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);
-	
     if (nil == dataPath)
     {
-		dataPath = [[[paths objectAtIndex: 0] stringByAppendingPathComponent: STORE_ARCHIVE_FILENAME] copy];
+        if (nil != context_)
+        {
+            NSString* cachePath = [[AFCache rootPath] stringByAppendingPathComponent:STORE_ARCHIVE_FILENAME];
+            dataPath = [[cachePath stringByAppendingPathComponent: context_] copy];            
+        }
+        else
+        {
+            dataPath = [[[AFCache rootPath] stringByAppendingPathComponent: STORE_ARCHIVE_FILENAME] copy];
+        }
     }
 	NSString *filename = [dataPath stringByAppendingPathComponent: kAFCacheExpireInfoDictionaryFilename];
 	self.clientItems = nil;
@@ -199,7 +273,8 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 			if ([keys count] > 0) {
 				key = [keys objectAtIndex:0];
 				//[self removeObjectForURLString:key fileOnly:NO];
-				[self removeCacheEntryWithFilePath:key fileOnly:NO];
+                NSString* fullPath = [[self dataPath] stringByAppendingPathComponent:key];
+				[self removeCacheEntryWithFilePath:fullPath fileOnly:NO];
 			}
 		}
 	}
@@ -328,7 +403,6 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 							   username: (NSString *)aUsername
 							   password: (NSString *)aPassword
 {
-	
 	requestCounter++;
     BOOL invalidateCacheEntry = (options & kAFCacheInvalidateEntry) != 0;
     BOOL revalidateCacheEntry = (options & kAFCacheRevalidateEntry) != 0;
@@ -340,7 +414,8 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 		// try to get object from disk
 		if (self.cacheEnabled && invalidateCacheEntry == 0) {
 			item = [self cacheableItemFromCacheStore: internalURL];
-			if ([item hasDownloadFileAttribute] || ![item hasValidContentLength])
+			if (![item isDataLoaded] &&
+                ([item hasDownloadFileAttribute] || ![item hasValidContentLength]))
 			{
                 if (nil == [pendingConnections objectForKey:internalURL])
 				{
@@ -573,7 +648,7 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 		return; // this is serious. we need this directory.
 	}
 	self.cacheInfoStore = [NSMutableDictionary dictionary];
-	[[AFCache sharedInstance] archive];
+	[self archive];
 }
 
 - (NSString *)filenameForURL: (NSURL *) url {
@@ -801,31 +876,26 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 {
 	if (nil != itemDelegate)
     {
-        NSArray *allKeys = [clientItems allKeys];
-		for (NSURL *url in allKeys)
+        NSMutableArray* const clientItemsForURL = [clientItems objectForKey:url];
+        
+        for (AFCacheableItem* item in [[clientItemsForURL copy] autorelease])
         {
-            NSMutableArray* const clientItemsForURL = [clientItems objectForKey:url];
-            
-            for (AFCacheableItem* item in [[clientItemsForURL copy] autorelease])
+            if (itemDelegate == item.delegate &&
+                selector == item.connectionDidFinishSelector)
             {
-                if (itemDelegate == item.delegate &&
-					[[url absoluteString] isEqualToString:[item.url absoluteString]] &&
-					selector == item.connectionDidFinishSelector)
+                [self removeFromDownloadQueue:item];
+                item.delegate = nil;
+                [self cancelConnectionsForURL:url];
+                
+                [clientItemsForURL removeObjectIdenticalTo:item];
+                
+                if ( ![clientItemsForURL count] )
                 {
-					[self removeFromDownloadQueue:item];
-					item.delegate = nil;
-                    [self cancelConnectionsForURL:url];
-					
-                    [clientItemsForURL removeObjectIdenticalTo:item];
-                    
-                    if ( ![clientItemsForURL count] )
-                    {
-                        [clientItems removeObjectForKey:url];
-                    }
+                    [clientItems removeObjectForKey:url];
                 }
             }
         }
-		
+        
         [self archive];
 		[self fillPendingConnections];
     }	
@@ -865,13 +935,18 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
     }	
 }
 
-- (void)cancelAllClientItems
+- (void)cancelPendingConnections
 {
     for (NSURLConnection* connection in [pendingConnections allValues])
     {
         [connection cancel];
     }
     [pendingConnections removeAllObjects];
+}
+
+- (void)cancelAllClientItems
+{
+    [self cancelPendingConnections];
     
     for (NSArray* items in [clientItems allValues])
     {
@@ -913,6 +988,35 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
     return [[[clientItems objectForKey:url] copy] autorelease];
 }
 
+- (NSArray*)cacheableItemsForDelegate:(id)delegate didFinishSelector:(SEL)didFinishSelector
+{
+    if (nil != delegate)
+    {
+        NSMutableArray* items = [NSMutableArray array];
+        NSArray *allKeys = [clientItems allKeys];
+		for (NSURL *url in allKeys)
+        {
+            NSMutableArray* const clientItemsForURL = [clientItems objectForKey:url];
+            
+            for (AFCacheableItem* item in [[clientItemsForURL copy] autorelease])
+            {
+                if (delegate == item.delegate &&
+                    item.connectionDidFinishSelector == didFinishSelector)
+                {
+                    [items addObject:item];
+                }
+            }
+        }
+        
+        if ([items count] != 0)
+        {
+            return items;
+        }
+    }
+    
+    return nil;
+}
+
 - (void)signalItemsForURL:(NSURL*)url usingSelector:(SEL)selector
 {
     NSArray* items = [self cacheableItemsForURL:url];
@@ -927,6 +1031,8 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 }
 
 - (void)removeItemsForURL:(NSURL*)url {
+    NSArray* items = [clientItems objectForKey:url];
+    [downloadQueue removeObjectsInArray:items];
 	[clientItems removeObjectForKey:url];
 }
 
@@ -976,6 +1082,7 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 			[self downloadItem:item];
 		}
 	}
+
 }
 
 
@@ -1036,13 +1143,34 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 	return NO;
 }
 
-
+- (void)prioritizeItem:(AFCacheableItem*)item
+{
+    // find the item that is actually downloading and put it into the pole position
+    for (AFCacheableItem* cacheableItem in [self cacheableItemsForURL:item.url])
+    {
+        if ([downloadQueue containsObject:cacheableItem])
+        {
+            [cacheableItem retain];
+            [downloadQueue removeObject:cacheableItem];
+            [downloadQueue insertObject:cacheableItem atIndex:0];
+            [cacheableItem release];
+        }
+    }
+}
 
 // Download item if we need to.
 - (void)downloadItem:(AFCacheableItem*)item
 {
-    // Remove the item from the queue, becaue we are going to download the item now
+	if (self.pauseDownload == YES)
+	{
+		// Do not start any connection right now, because AFCache is paused
+		return;
+	}
+		
+	// Remove the item from the queue, becaue we are going to download the item now
     [downloadQueue removeObject:item];
+	
+	
     
     // check if we are downloading already
     if (nil != [pendingConnections objectForKey:item.url])
@@ -1053,7 +1181,8 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 #endif            
         return;
     }
-    
+	
+	  
     NSURLRequest *theRequest = [NSURLRequest requestWithURL: item.url
                                                 cachePolicy: NSURLRequestReloadIgnoringLocalCacheData
                                             timeoutInterval: kAFCacheRequestTimeout];
@@ -1077,7 +1206,48 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
     return NO;
 }
 
-#pragma mark offline methods
+#pragma mark offline & pause methods
+
+- (void)setPauseDownload:(BOOL)pause
+{
+
+	pauseDownload_ = pause;
+	
+	if (pause == YES)
+	{
+        [packageArchiveQueue_ setSuspended:YES];
+		// Check for running connection -> add the items to the queue again
+        NSMutableArray* allItems = [NSMutableArray array];
+		for (NSURL* url in [pendingConnections allKeys])
+		{
+            [allItems addObjectsFromArray:[clientItems objectForKey:url]];
+        }
+
+        [self cancelPendingConnections];
+
+        for (AFCacheableItem* item in allItems)
+        {
+            if (![downloadQueue containsObject:item])
+            {
+                [downloadQueue insertObject:item atIndex:0];   // retain count +1 because we are removing it from clientItems afterwards (which decreases the retain count again)
+            }
+        }
+	}
+	else
+	{
+        [packageArchiveQueue_ setSuspended:NO];
+		// Resume downloading
+		for (int i = 0; i < concurrentConnections; i++)
+		{
+			if ([[pendingConnections allKeys] count] < concurrentConnections)
+			{
+				[self downloadNextEnqueuedItem];
+			}
+		}
+		
+	}
+
+}
 
 - (void)setOffline:(BOOL)value {
 	_offline = value;
@@ -1117,42 +1287,41 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 + (AFCache *)sharedInstance {
 	@synchronized(self) {
 		if (sharedAFCacheInstance == nil) {
-			sharedAFCacheInstance = [[self alloc] init];
+			sharedAFCacheInstance = [[self alloc] initWithContext:nil];
 			sharedAFCacheInstance.diskCacheDisplacementTresholdSize = kDefaultDiskCacheDisplacementTresholdSize;
-			sharedAFCacheInstance.downloadPermission = YES;
 		}
 	}
 	return sharedAFCacheInstance;
 }
 
-+ (id)allocWithZone: (NSZone *) zone {
-	@synchronized(self) {
-		if (sharedAFCacheInstance == nil) {
-			sharedAFCacheInstance = [super allocWithZone: zone];
-			return sharedAFCacheInstance;  // assignment and return on first allocation
-		}
-	}
-	return nil; //on subsequent allocation attempts return nil
-}
-
-- (id)copyWithZone: (NSZone *) zone {
-	return self;
-}
-
-- (id)retain {
-	return self;
-}
-
-- (NSUInteger)retainCount {
-	return UINT_MAX;  //denotes an object that cannot be released
-}
-
-- (void)release {
-}
-
-- (id)autorelease {
-	return self;
-}
+//+ (id)allocWithZone: (NSZone *) zone {
+//	@synchronized(self) {
+//		if (sharedAFCacheInstance == nil) {
+//			sharedAFCacheInstance = [super allocWithZone: zone];
+//			return sharedAFCacheInstance;  // assignment and return on first allocation
+//		}
+//	}
+//	return nil; //on subsequent allocation attempts return nil
+//}
+//
+//- (id)copyWithZone: (NSZone *) zone {
+//	return self;
+//}
+//
+//- (id)retain {
+//	return self;
+//}
+//
+//- (NSUInteger)retainCount {
+//	return UINT_MAX;  //denotes an object that cannot be released
+//}
+//
+//- (void)release {
+//}
+//
+//- (id)autorelease {
+//	return self;
+//}
 
 - (void)dealloc {
     [[NSNotificationCenter defaultCenter] removeObserver:self];
@@ -1166,6 +1335,11 @@ static NSString *STORE_ARCHIVE_FILENAME = @ "urlcachestore";
 	[clientItems release];
 	[dataPath release];
 	
+    if (nil != context_)
+    {
+        [AFCache_contextCache removeObjectForKey:context_];
+    }
+    
 	[super dealloc];
 }
 
diff --git a/AFCacheableItem.h b/AFCacheableItem.h
index 52bb087..5d07bb5 100755
--- a/AFCacheableItem.h
+++ b/AFCacheableItem.h
@@ -65,6 +65,7 @@ enum kCacheStatus {
 	int tag; // for debugging and testing purposes
 	BOOL isPackageArchive;
 	uint64_t currentContentLength;
+    
     NSFileHandle*   fileHandle;
 	
 	/*
@@ -111,6 +112,7 @@ enum kCacheStatus {
 - (void)validateCacheStatus;
 - (uint64_t)currentContentLength;
 - (BOOL)isComplete;
+- (BOOL)isDataLoaded;
 
 - (NSString *)filename;
 - (NSString *)asString;
diff --git a/AFCacheableItem.m b/AFCacheableItem.m
index f9b838d..c2ff119 100755
--- a/AFCacheableItem.m
+++ b/AFCacheableItem.m
@@ -75,7 +75,7 @@
         
         if (nil == data)
         {
-            NSLog(@"Error: Could not map file %Q", filePath);
+            NSLog(@"Error: Could not map file %@", filePath);
         }
     }
 	
@@ -107,7 +107,6 @@
 		statusCode = (NSUInteger)[response performSelector:@selector(statusCode)];
 	}
 	self.info.statusCode = statusCode;
-	
 	// The resource has not been modified, so we call connectionDidFinishLoading and exit here.
 	if (self.cacheStatus==kCacheStatusRevalidationPending) {
 		switch (statusCode) {
@@ -120,9 +119,9 @@
 				
 				break;
 		}
-	} else {
-		self.info.responseTimestamp = [now timeIntervalSinceReferenceDate];
-	}
+	} 
+	
+    self.info.responseTimestamp = [now timeIntervalSinceReferenceDate];
 	
     if (200 == statusCode)
     {
@@ -386,10 +385,7 @@
     }
     
     // Remove reference to pending connection to unlink the item from the cache
-    [cache removeReferenceToConnection: connection];
-	[cache removeFromDownloadQueueAndLoadNext:self];
-	
-	
+    [cache removeReferenceToConnection: connection];	
 	
     NSArray* items = [self.cache cacheableItemsForURL:self.url];
     
@@ -405,6 +401,7 @@
         [self signalItemsDidFinish:items];
     }
     
+    [cache downloadNextEnqueuedItem];
 }
 
 - (void)signalItems:(NSArray*)items usingSelector:(SEL)selector
@@ -457,7 +454,6 @@
     [fileHandle release];
     fileHandle = nil;
     [cache removeReferenceToConnection: connection];
-	[cache removeFromDownloadQueueAndLoadNext:self];
 	
 	if (nil != self.data && self.isRevalidating)
     {
@@ -488,6 +484,7 @@
             [self signalItemsDidFail:items];
         }
     }
+    [cache downloadNextEnqueuedItem];
 }
 
 /*
@@ -639,6 +636,7 @@
 		return NO;
 	}
 	
+//    NSLog(@"has valid content length ? %@", self.url);
 	NSError* err = nil;
 	NSDictionary* attr = [[NSFileManager defaultManager] attributesOfItemAtPath:filePath error:&err];
 	if (nil != err)
@@ -758,7 +756,12 @@
 }
 
 - (BOOL)isComplete {
-	return (currentContentLength >= info.contentLength)?YES:NO;
+    return (currentContentLength >= info.contentLength)?YES:NO;
+}
+
+- (BOOL)isDataLoaded
+{
+    return data != nil;
 }
 
 - (void) dealloc {
@@ -770,6 +773,7 @@
 	[data release];
 	[username release];
 	[password release];
+    [fileHandle release];
 	
 	[super dealloc];
 }
